generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * If you prefer pure "string" columns like in the diagram,
 * you can keep these as String instead of enums.
 * Enums are cleaner & safer.
 */
enum BillingCycle {
  MONTHLY
  ANNUAL
}

enum SubscriptionStatus {
  ACTIVE
  PAUSED
  CANCELED
}

enum PaymentStatus {
  DUE
  PAID
  FAILED
  VOID
}

enum RoleLevel {
  MANAGER
  TECHNICIAN
  MACHINE
}

model Customer {
  customerID   Int      @id @default(autoincrement())
  firstName    String
  lastName     String
  email        String?  @unique
  ccExpiration DateTime?
  createdAt    DateTime @default(now())

  subscriptions Subscription[]
}

model Package {
  packageID   Int      @id @default(autoincrement())
  monthlyCost Int
  annualCost  Int

  subscriptions Subscription[]
}

model Subscription {
  subscriptionID Int                @id @default(autoincrement())

  customerID     Int
  packageID      Int

  billingCycle   BillingCycle
  status         SubscriptionStatus

  startDate      DateTime           @default(now())
  endDate        DateTime?
  price          Int                // matches diagram "price int" (you can rename to priceCents if you want)

  customer       Customer           @relation(fields: [customerID], references: [customerID], onDelete: Cascade)
  package        Package            @relation(fields: [packageID], references: [packageID], onDelete: Restrict)

  payments       Payment[]

  @@index([customerID])
  @@index([packageID])
}

model Payment {
  paymentID       Int           @id @default(autoincrement())
  subscriptionID  Int

  dueDate         DateTime
  paidAt          DateTime?
  status          PaymentStatus

  subscription    Subscription  @relation(fields: [subscriptionID], references: [subscriptionID], onDelete: Cascade)

  @@index([subscriptionID])
  @@index([status, dueDate])
}

model DataJson {
  data_json_ID Int   @id @default(autoincrement())
  data_json    Json

  analytics    Analytics[]
}

model Analysis {
  analysisID          Int     @id @default(autoincrement())
  analysisName        String
  analysisDescription String

  analyticsRuns       Analytics[]
}

model Analytics {
  analyticsID     Int      @id @default(autoincrement())

  // diagram calls it analysisTypeID but it's FK to Analysis.analysisID
  analysisTypeID  Int
  userID          Int
  ran_on          DateTime @default(now())

  data_json_ID    Int

  analysisType    Analysis @relation(fields: [analysisTypeID], references: [analysisID], onDelete: Restrict)
  user            User     @relation(fields: [userID], references: [userID], onDelete: Cascade)
  dataJson        DataJson @relation(fields: [data_json_ID], references: [data_json_ID], onDelete: Restrict)

  @@index([analysisTypeID])
  @@index([userID])
  @@index([data_json_ID])
}

model Level {
  levelID Int       @id @default(autoincrement())
  level   RoleLevel @unique

  users   User[]
}

model User {
  userID      Int      @id @default(autoincrement())

  // MUST be String for Firebase UID
  firebaseUid String   @unique

  firstName   String
  lastName    String

  levelID     Int
  level       Level    @relation(fields: [levelID], references: [levelID], onDelete: Restrict)

  analytics   Analytics[]
}
