// server/src/routes/data.routes.js
import express from "express";
import fs from "fs";
import path from "path";

const router = express.Router();

const DATA_DIR = path.resolve(process.env.DATA_DIR || "/app/data");

// Ensure folder exists (safe in Docker + local)
try {
  if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });
} catch (err) {
  console.warn("[data.routes] Could not ensure DATA_DIR exists:", DATA_DIR, err);
}

// ---------- helpers ----------
function isUnsafeName(name) {
  return (
    !name ||
    name.includes("..") ||
    name.includes("/") ||
    name.includes("\\") ||
    name.trim() !== name
  );
}

function normalizeJsonName(name) {
  let n = String(name || "");
  if (!n.toLowerCase().endsWith(".json")) n += ".json";
  return n;
}

function getFilePath(nameOrFilename) {
  const filename = normalizeJsonName(nameOrFilename);
  return path.join(DATA_DIR, filename);
}

/**
 * ✅ GET /api/data/db/schema
 * Serves the prisma-derived schema JSON generated by the seeder:
 *   ${DATA_DIR}/db-info/db_schema.json
 *
 * This is a fixed path (NOT user-provided), so it’s safe.
 */
router.get("/db/schema", (req, res) => {
  try {
    const filePath = path.join(DATA_DIR, "db-info", "db_schema.json");

    if (!fs.existsSync(filePath)) {
      return res.status(404).json({
        error: "db_schema.json not found",
        expectedPath: filePath,
      });
    }

    res.setHeader("Content-Type", "application/json; charset=utf-8");
    res.setHeader("Cache-Control", "no-store");
    res.send(fs.readFileSync(filePath, "utf-8"));
  } catch (err) {
    console.error("[data.routes] db/schema error:", err);
    res.status(500).json({ error: "Failed to read db schema JSON" });
  }
});

/**
 * GET /api/data
 * Lists all .json files in DATA_DIR
 */
router.get("/", (req, res) => {
  try {
    const files = fs
      .readdirSync(DATA_DIR, { withFileTypes: true })
      .filter((d) => d.isFile() && d.name.toLowerCase().endsWith(".json"))
      .map((d) => d.name)
      .sort();

    res.json({ files });
  } catch (err) {
    console.error("[data.routes] list error:", err);
    res.status(500).json({ error: "Failed to list data files" });
  }
});

/**
 * GET /api/data/_meta/:name
 * Returns file metadata (size + modified time)
 * Works with /_meta/foo OR /_meta/foo.json
 */
router.get("/_meta/:name", (req, res) => {
  try {
    const name = String(req.params.name || "");
    if (isUnsafeName(name)) return res.status(400).json({ error: "Invalid name" });

    const filename = normalizeJsonName(name);
    const filePath = getFilePath(filename);

    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ error: "File not found" });
    }

    const st = fs.statSync(filePath);
    return res.json({
      file: filename,
      bytes: st.size,
      modifiedAt: st.mtime.toISOString(),
    });
  } catch (err) {
    console.error("[data.routes] meta error:", err);
    res.status(500).json({ error: "Failed to read metadata" });
  }
});

/**
 * GET /api/data/:name
 * Serves a JSON file from DATA_DIR.
 * Accepts both:
 *   /api/data/foo
 *   /api/data/foo.json
 */
router.get("/:name", (req, res) => {
  try {
    const name = String(req.params.name || "");
    if (isUnsafeName(name)) return res.status(400).json({ error: "Invalid name" });

    const filename = normalizeJsonName(name);
    const filePath = getFilePath(filename);

    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ error: "File not found" });
    }

    res.setHeader("Content-Type", "application/json; charset=utf-8");
    res.setHeader("Cache-Control", "no-store");
    res.send(fs.readFileSync(filePath, "utf-8"));
  } catch (err) {
    console.error("[data.routes] read error:", err);
    res.status(500).json({ error: "Failed to read data file" });
  }
});

export default router;
